name: üóÇÔ∏è Airtable Documentation Sync

on:
  schedule:
    - cron: '0 8 * * *'  # Daily at 8 AM UTC
  workflow_dispatch:      # Manual trigger
    inputs:
      base:
        description: 'Which Airtable base to sync'
        required: false
        default: 'default'
        type: choice
        options:
        - default
        - aulas

permissions:
  contents: write

jobs:
  sync-documentation:
    runs-on: ubuntu-latest
    
    steps:
    # 1. Checkout repository
    - name: üì• Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    # 2. Setup Python
    - name: üêç Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    # 3. Install dependencies
    - name: üì¶ Install dependencies
      run: pip install requests
    
    # 4. Determinar qu√© base sincronizar
    - name: üîç Determine which base to sync
      id: select-base
      run: |
        if [[ "${{ github.event.inputs.base }}" == "aulas" ]]; then
          echo "üîÑ Selected: Aulas base"
          echo "ENV_SUFFIX=_AULAS" >> $GITHUB_OUTPUT
          echo "OUTPUT_FILE=database-structure-aulas.md" >> $GITHUB_OUTPUT
          echo "SECRET_TOKEN=AIRTABLE_TOKEN_AULAS" >> $GITHUB_OUTPUT
          echo "SECRET_BASE_ID=AIRTABLE_BASE_ID_AULAS" >> $GITHUB_OUTPUT
        else
          echo "üîÑ Selected: Default base"
          echo "ENV_SUFFIX=" >> $GITHUB_OUTPUT
          echo "OUTPUT_FILE=database-structure.md" >> $GITHUB_OUTPUT
          echo "SECRET_TOKEN=AIRTABLE_TOKEN" >> $GITHUB_OUTPUT
          echo "SECRET_BASE_ID=AIRTABLE_BASE_ID" >> $GITHUB_OUTPUT
        fi
    
    # 5. Generate documentation (VERSI√ìN CORREGIDA)
    - name: üîÑ Generate Airtable documentation
      id: generate-docs
      env:
        # Pasar TODOS los secretos relevantes al ambiente
        AIRTABLE_TOKEN_DEFAULT: ${{ secrets.AIRTABLE_TOKEN }}
        AIRTABLE_BASE_ID_DEFAULT: ${{ secrets.AIRTABLE_BASE_ID }}
        AIRTABLE_TOKEN_AULAS: ${{ secrets.AIRTABLE_TOKEN_AULAS }}
        AIRTABLE_BASE_ID_AULAS: ${{ secrets.AIRTABLE_BASE_ID_AULAS }}
        OUTPUT_FILE: ${{ steps.select-base.outputs.OUTPUT_FILE }}
      run: |
        echo "=== GENERATING DOCUMENTATION ==="
        echo "üìÅ Output file: $OUTPUT_FILE"
        echo "üîë Base selection: ${{ github.event.inputs.base }}"
        
        # Determinar qu√© variables usar basado en la selecci√≥n
        if [[ "${{ github.event.inputs.base }}" == "aulas" ]]; then
          echo "üîÑ Using Aulas credentials"
          export AIRTABLE_TOKEN="$AIRTABLE_TOKEN_AULAS"
          export AIRTABLE_BASE_ID="$AIRTABLE_BASE_ID_AULAS"
          echo "‚úÖ Token variable: AIRTABLE_TOKEN_AULAS"
          echo "‚úÖ Base ID variable: AIRTABLE_BASE_ID_AULAS"
        else
          echo "üîÑ Using Default credentials"
          export AIRTABLE_TOKEN="$AIRTABLE_TOKEN_DEFAULT"
          export AIRTABLE_BASE_ID="$AIRTABLE_BASE_ID_DEFAULT"
          echo "‚úÖ Token variable: AIRTABLE_TOKEN"
          echo "‚úÖ Base ID variable: AIRTABLE_BASE_ID"
        fi
        
        # Debug: mostrar que las variables est√°n configuradas
        echo "üîç Debug - Token length: ${#AIRTABLE_TOKEN}"
        echo "üîç Debug - Base ID: $AIRTABLE_BASE_ID"
        
        # Run the Python script
        python sync_airtable.py --output "$OUTPUT_FILE" --base "${{ github.event.inputs.base }}"
        
        # Verify the file was created
        if [ ! -f "$OUTPUT_FILE" ]; then
          echo "‚ùå ERROR: $OUTPUT_FILE was not created"
          exit 1
        fi

        echo "‚úÖ File created successfully"
        echo "üìè File size: $(wc -c < "$OUTPUT_FILE") bytes"
        echo "üìÑ Preview:"
        head -5 "$OUTPUT_FILE"
        
    # 6. Upload to GitHub using GitHub API (VERSI√ìN CORREGIDA - maneja archivos grandes)
    - name: üì§ Upload to GitHub Repository
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        REPO: ${{ github.repository }}
        FILE_PATH: ${{ steps.select-base.outputs.OUTPUT_FILE }}
      run: |
        echo "=== UPLOADING TO GITHUB REPOSITORY ==="
        echo "üìÅ Uploading: $FILE_PATH"
        
        # Check if file exists
        if [ ! -f "$FILE_PATH" ]; then
          echo "‚ùå ERROR: $FILE_PATH not found"
          exit 1
        fi
        
        # Encode file content to base64
        echo "üîß Encoding file to base64..."
        CONTENT_BASE64=$(base64 -w 0 "$FILE_PATH")
        FILE_SIZE=$(wc -c < "$FILE_PATH")
        BASE64_SIZE=${#CONTENT_BASE64}
        echo "üìè File size: $FILE_SIZE bytes"
        echo "üìè Base64 size: $BASE6464_SIZE characters"
        
        # Get file SHA if it exists
        echo "üîç Checking if file already exists in repository..."
        
        SHA=""
        API_RESPONSE=$(curl -s -H "Authorization: token $GH_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$REPO/contents/$FILE_PATH")
        
        # Extraer SHA usando jq
        SHA=$(echo "$API_RESPONSE" | jq -r '.sha // empty')
        
        if [ -n "$SHA" ] && [ "$SHA" != "null" ]; then
          echo "‚úÖ File exists. SHA: ${SHA:0:8}..."
          COMMIT_MESSAGE="üìö docs: update $FILE_PATH [auto]"
          NEED_SHA=true
        else
          echo "üÜï File doesn't exist, will create new"
          COMMIT_MESSAGE="üìö docs: create $FILE_PATH [auto]"
          NEED_SHA=false
        fi
        
        # Create JSON payload usando archivo temporal (EVITA error "Argument list too long")
        echo "üìù Creating JSON payload..."
        
        if [ "$NEED_SHA" = true ] && [ -n "$SHA" ]; then
          # Crear archivo temporal con JSON
          jq -n \
            --arg msg "$COMMIT_MESSAGE" \
            --arg content "$CONTENT_BASE64" \
            --arg sha "$SHA" \
            '{
              message: $msg,
              content: $content,
              sha: $sha,
              committer: {
                name: "GitHub Actions",
                email: "actions@github.com"
              },
              branch: "main"
            }' > /tmp/payload.json
        else
          # Crear archivo temporal sin SHA
          jq -n \
            --arg msg "$COMMIT_MESSAGE" \
            --arg content "$CONTENT_BASE64" \
            '{
              message: $msg,
              content: $content,
              committer: {
                name: "GitHub Actions",
                email: "actions@github.com"
              },
              branch: "main"
            }' > /tmp/payload.json
        fi
        
        echo "‚úÖ JSON payload created: /tmp/payload.json"
        echo "üìè Payload size: $(wc -c < /tmp/payload.json) bytes"
        
        echo "üöÄ Uploading file to GitHub..."
        
        # Make API call usando el archivo temporal
        UPLOAD_RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X PUT \
          -H "Authorization: token $GH_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          -H "Content-Type: application/json" \
          --data-binary @/tmp/payload.json \
          "https://api.github.com/repos/$REPO/contents/$FILE_PATH")
        
        # Extraer estado HTTP y respuesta
        HTTP_STATUS=$(echo "$UPLOAD_RESPONSE" | grep "HTTP_STATUS:" | cut -d':' -f2)
        JSON_RESPONSE=$(echo "$UPLOAD_RESPONSE" | grep -v "HTTP_STATUS:")
        
        echo "üìä HTTP Status: $HTTP_STATUS"
        
        # Check response
        if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ]; then
          echo "üéâ SUCCESS: File uploaded to repository!"
          
          # Get commit URL
          COMMIT_URL=$(echo "$JSON_RESPONSE" | jq -r '.commit.html_url // empty')
          
          if [ -n "$COMMIT_URL" ] && [ "$COMMIT_URL" != "null" ]; then
            echo "üîó View commit: $COMMIT_URL"
          fi
          
          # Get download URL
          DOWNLOAD_URL="https://raw.githubusercontent.com/$REPO/main/$FILE_PATH"
          echo "‚¨áÔ∏è  Download URL: $DOWNLOAD_URL"
          
          # Clean up temp file
          rm -f /tmp/payload.json
        else
          echo "‚ùå ERROR: Failed to upload file (Status: $HTTP_STATUS)"
          echo "Response preview:"
          echo "$JSON_RESPONSE" | head -200
          echo "..."
          
          # Mostrar m√°s detalles del error
          if [ -f "/tmp/payload.json" ]; then
            echo "üìÑ Payload preview (first 500 chars):"
            head -c 500 /tmp/payload.json
            echo "..."
          fi
          
          exit 1
        fi
        
    # 7. Create artifact for backup
    - name: üóÉÔ∏è Create backup artifact
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.select-base.outputs.OUTPUT_FILE }}
        path: ${{ steps.select-base.outputs.OUTPUT_FILE }}
        retention-days: 7
